<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Luis Ascorbe"/><link rel="canonical" href="https://lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part2"/><meta name="twitter:url" content="https://lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part2"/><meta name="og:url" content="https://lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part2"/><title>MVP + Coordinators in SwiftUI (part 2) | Luis Ascorbe</title><meta name="twitter:title" content="MVP + Coordinators in SwiftUI (part 2) | Luis Ascorbe"/><meta name="og:title" content="MVP + Coordinators in SwiftUI (part 2) | Luis Ascorbe"/><meta name="description" content="2nd part of exploring a MVP+Coordinators approach on SwiftUI without using UIKit."/><meta name="twitter:description" content="2nd part of exploring a MVP+Coordinators approach on SwiftUI without using UIKit."/><meta name="og:description" content="2nd part of exploring a MVP+Coordinators approach on SwiftUI without using UIKit."/><meta name="twitter:card" content="summary"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Luis Ascorbe"/><meta name="twitter:image" content="https://lascorbe.com/android-chrome-512x512.png"/><meta name="og:image" content="https://lascorbe.com/android-chrome-512x512.png"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47" crossorigin="anonymous"/><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/grids-responsive-min.css" type="text/css"/><link rel="stylesheet" href="/Pure/styles.css" type="text/css"/><link rel="stylesheet" href="/FontAwesomeCSS/all.css" type="text/css"/><link rel="icon" href="/favicon-32x32.png" type="image/png" sizes="32x32"/><link rel="icon" href="/favicon-16x16.png" type="image/png" sizes="16x16"/><link rel="apple-touch-icon" href="/apple-touch-icon.png" type="image/png" sizes="180x180"/><link rel="manifest" href="/site.webmanifest"/></head><body><div id="layout" class="pure-g"><div class="sidebar pure-u-1 pure-u-md-1-4"><div class="sidebar-header"><div><div class="pure-menu pure-menu-horizontal"><ul class="pure-menu-list"><li class="pure-menu-item pure-menu-selected"><a class="pure-menu-link" href="/">Blog</a></li><li class="pure-menu-item pure-menu-selected"><a class="pure-menu-link" href="/about">About</a></li></ul></div></div></div><div class="sidebar-profile"><div id="layout" class="pure-g"><div class="author__avatar"><img src="https://avatars0.githubusercontent.com/u/1515520?s=460&v=4"/></div><div class="pure-u-md-1-1 pure-u-3-4"><h1 class="brand-title"><a href="/">Luis Ascorbe</a></h1><h3 class="brand-tagline">Software Developer. Tech Lead. Speaker. Conference Organizer.</h3></div></div><div class="social-media-container"><div id="layout" class="pure-g"><div class="pure-u-md-1-1"><a href="mailto:hi+blog@ascor.be" target="_blank"><i class="far fa-envelope l-box social-icon"></i><a class="social-media" href="mailto:hi+blog@ascor.be" target="_blank">Email</a></a></div><div class="pure-u-md-1-1"><a href="https://github.com/lascorbe" target="_blank"><i class="fab fa-github l-box social-icon"></i><a class="social-media" href="https://github.com/lascorbe" target="_blank">GitHub</a></a></div><div class="pure-u-md-1-1"><a href="https://twitter.com/lascorbe" target="_blank"><i class="fab fa-twitter l-box social-icon"></i><a class="social-media" href="https://twitter.com/lascorbe" target="_blank">Twitter</a></a></div><div class="pure-u-md-1-1"><a href="https://www.linkedin.com/in/lascorbe" target="_blank"><i class="fab fa-linkedin l-box social-icon"></i><a class="social-media" href="https://www.linkedin.com/in/lascorbe" target="_blank">LinkedIn</a></a></div></div></div></div></div><div class="content pure-u-1 pure-u-md-3-4 pure-u-xl-6-10"><h2 class="post-title">MVP + Coordinators in SwiftUI (part 2)</h2><p class="post-meta">27 April 2020 · ⏱ 10 minutes</p><div class="post-tags"><a class="post-category post-category-swiftui" href="/tags/swiftui">swiftui</a><a class="post-category post-category-coordinator" href="/tags/coordinator">coordinator</a><a class="post-category post-category-mvp" href="/tags/mvp">mvp</a><a class="post-category post-category-article" href="/tags/article">article</a></div><div class="post-description"><div class="description-text"><img src="/images/posts/2020-04-26-MVPCoordinators-SwiftUI/1.jpg"/><p><em>Public repo: For those of you who want to check out the code right away here is the repo: <a href="https://github.com/Lascorbe/SwiftUI-MVP-Coordinator">https://github.com/Lascorbe/SwiftUI-MVP-Coordinator</a>.</em></p><p>This is the 2nd part of the blog posts on creating an MVP+Coordinators app with SwiftUI. If you're looking for the 1st part, please go here: <a href="https://lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part1">lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part1</a></p><p>The last thing we did in <em>part 1</em> was moving <code>NavigationView</code> out of the <code>MasterView</code> and "hidding" <code>NavigationLink</code> as the background view of the Button's text:</p><pre><code><span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">MasterPresenting</span>
  
    <span class="la-keyword">@State private var</span> isPresented = <span class="la-keyword">false
  
    var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">Button</span>(action: {
            <span class="la-keyword">self</span>.<span class="la-property">isPresented</span> = <span class="la-keyword">true</span>
        }) {
            <span class="la-type">Text</span>(<span class="la-string">"</span>\(viewModel.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>) 
                .<span class="la-call">background</span>(
                    <span class="la-type">NavigationLink</span>(destination: <span class="la-type">EmptyView</span>(), isActive: $isPresented) {
                        <span class="la-type">EmptyView</span>()
                    }
                )
        }
    }
}
</code></pre><p>Now we can extract <code>NavigationLink</code>, so the button in <code>MasterView</code> will look like this:</p><pre><code><span class="la-type">Button</span>(action: {
    <span class="la-keyword">self</span>.<span class="la-property">isPresented</span> = <span class="la-keyword">true</span>
}) {
    <span class="la-type">Text</span>(<span class="la-string">"</span>\(viewModel.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>) 
        .<span class="la-call">background</span>(
				    <span class="la-keyword">self</span>.<span class="la-property">presenter</span>.<span class="la-call">onButtonPressed</span>(isPresented: $isPresented)
        )
}
</code></pre><p>See how we switched <code>NavigationLink</code> with a presenter's function. And now I ask, where do we move <code>NavigationLink</code> to? The presenter? Nop! To the coordinator! But first, let's implement this method in the presenter:</p><pre><code><span class="la-keyword">protocol</span> MasterPresenting: <span class="la-type">ObservableObject</span> {
    <span class="la-keyword">associatedtype</span> U: <span class="la-type">View</span>                                
    <span class="la-keyword">var</span> viewModel: <span class="la-type">MasterViewModel</span> { <span class="la-keyword">get</span> }
    <span class="la-keyword">func</span> onButtonPressed(isPresented: <span class="la-type">Binding</span>&lt;<span class="la-type">Bool</span>&gt;) -&gt; <span class="la-type">U</span> <span class="la-comment">// we return a</span> 
}

<span class="la-keyword">final class</span> MasterPresenter: <span class="la-type">MasterPresenting</span> {
    <span class="la-keyword">@Published private(set) var</span> viewModel: <span class="la-type">MasterViewModel</span>
  
    <span class="la-keyword">private let</span> coordinator: <span class="la-type">MasterCoordinator</span>
    
    <span class="la-keyword">init</span>(coordinator: <span class="la-type">MasterCoordinator</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">coordinator</span> = coordinator
    }
  
    <span class="la-keyword">func</span> onButtonPressed(isPresented: <span class="la-type">Binding</span>&lt;<span class="la-type">Bool</span>&gt;) -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> { <span class="la-comment">// using `some` we don't have to specify the MasterPresenting's associatedtype</span>
        <span class="la-keyword">return</span> coordinator.<span class="la-call">presentDetailView</span>(isPresented: isPresented)
    }
}
</code></pre><p>We have to return a SwiftUI View, which can only be used as a generic constraint, so we need to specify an <code>associatedtype</code> in our <code>MasterPresenting</code> protocol. Notice how with the <code>some</code> keyword we don't have to specify the <code>associatedtype</code>.</p><p>Also look at <code>coordinator.presentDetailView</code>, it's returning a View. We're going there next but first we have to modify our <code>MasterView</code> because is using a generic protocol now:</p><pre><code><span class="la-keyword">struct</span> MasterView&lt;T: <span class="la-type">MasterPresenting</span>&gt;: <span class="la-type">View</span> { <span class="la-comment">// `T` arrived!</span>
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">T</span>
  
    {...}
}
</code></pre><p>Since we don't want <code>MasterView</code> to know what <code>MasterPresenting</code> we're injecting, let's tell it on construction.</p><p>Now we can go to our coordinator and add the <code>presentDetailView</code> function. Remember we had a <code>MasterCoordinator</code> protocol which was empty? Not anymore:</p><pre><code><span class="la-keyword">protocol</span> MasterCoordinator: <span class="la-type">Coordinator</span> {}

<span class="la-keyword">extension</span> <span class="la-type">MasterCoordinator</span>: <span class="la-type">Coordinator</span> {
    <span class="la-keyword">func</span> presentDetailView(isPresented: <span class="la-type">Binding</span>&lt;<span class="la-type">Bool</span>&gt;) -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">let</span> coordinator = <span class="la-type">NavigationDetailCoordinator</span>(isPresented: isPresented)
        <span class="la-keyword">return</span> <span class="la-call">coordinate</span>(to: coordinator)
    }
}
</code></pre><p>Since <code>presentDetailView</code> is a <em>pure</em> function, we can add it to the <code>MasterCoordinator</code> protocol's extension.</p><p>Notice that we have a new coordinator, <code>NavigationDetailCoordinator</code>, it's exactly where we're going to put the <code>NavigationLink</code>:</p><pre><code><span class="la-keyword">final class</span> NavigationDetailCoordinator: <span class="la-type">Coordinator</span> {
    <span class="la-keyword">private var</span> isPresented: <span class="la-type">Binding</span>&lt;<span class="la-type">Bool</span>&gt;
    
    <span class="la-keyword">init</span>(isPresented: <span class="la-type">Binding</span>&lt;<span class="la-type">Bool</span>&gt;) {
        <span class="la-keyword">self</span>.<span class="la-property">isPresented</span> = isPresented
    }
    
    <span class="la-keyword">func</span> start() -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">return</span> <span class="la-type">NavigationLink</span>(destination: <span class="la-type">EmptyView</span>(), isActive: isPresented) {
            <span class="la-type">EmptyView</span>()
        }
    }
}
</code></pre><p>Great! Hmmm but now we have a problem, we're returning a View from <code>start()</code>, but the <code>Coordinator</code> protocol implementation is not returning anything.</p><p>Let's change it then, this is our new <code>Coordinator</code>:</p><pre><code><span class="la-keyword">protocol</span> Coordinator {
    <span class="la-keyword">associatedtype</span> U: <span class="la-type">View</span>
    <span class="la-keyword">func</span> start() -&gt; <span class="la-type">U</span>
}

<span class="la-keyword">extension</span> <span class="la-type">Coordinator</span> {
    <span class="la-keyword">func</span> coordinate&lt;T: <span class="la-type">Coordinator</span>&gt;(to coordinator: <span class="la-type">T</span>) -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">return</span> coordinator.<span class="la-call">start</span>()
    }
}
</code></pre><p>Ok, we redo our <code>start</code> and <code>coordinate</code> methods, now both of them return a View. We rely on the power of generics and the keyword <code>some</code> to avoid specifying them.</p><p>Since we're now relying on a generic protocol for the coordinators, we have to change the implementation of the <code>AppCoordinator</code>, <code>MasterFactory</code> and <code>MasterPresenter</code> like so:</p><pre><code><span class="la-keyword">final class</span> AppCoordinator: <span class="la-type">Coordinator</span> {
    {...}
    
    <span class="la-keyword">func</span> start() -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">let</span> coordinator = <span class="la-type">NavigationMasterCoordinator</span>(window: window)
        <span class="la-keyword">return</span> coordinator.<span class="la-call">coordinate</span>(to: coordinator)
    }
}

<span class="la-keyword">final class</span> RootMasterCoordinator: <span class="la-type">MasterCoordinator</span> {
    {...}
    
    <span class="la-keyword">func</span> start() -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">let</span> view = <span class="la-type">MasterFactory</span>.<span class="la-call">make</span>(with: <span class="la-keyword">self</span>)
        <span class="la-keyword">let</span> navigation = <span class="la-type">NavigationView</span> { view }
        <span class="la-keyword">let</span> hosting = <span class="la-type">UIHostingController</span>(rootView: navigation)
        window?.<span class="la-property">rootViewController</span> = hosting
        window?.<span class="la-call">makeKeyAndVisible</span>()
        <span class="la-keyword">return</span> <span class="la-type">EmptyView</span>() <span class="la-comment">// we just have to return something</span>
    }
}

<span class="la-keyword">enum</span> MasterFactory {
    <span class="la-keyword">static func</span> make&lt;C: <span class="la-type">MasterCoordinator</span>&gt;(with coordinator: <span class="la-type">C</span>) -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        {...}
    }
}

<span class="la-keyword">final class</span> MasterPresenter&lt;C: <span class="la-type">MasterCoordinator</span>&gt;: <span class="la-type">MasterPresenting</span> {
    <span class="la-keyword">@Published private(set) var</span> viewModel: <span class="la-type">MasterViewModel</span>
  
    <span class="la-keyword">private let</span> coordinator: <span class="la-type">C</span>
    
    <span class="la-keyword">init</span>(coordinator: <span class="la-type">C</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">coordinator</span> = coordinator
    }
  
    {...}
}
</code></pre><p>Check out the <code>some View</code> and <code>&lt;C: MasterCoordinator&gt;</code> parts, we are just conforming to the <code>Coordinator</code> protocol.</p><p>Aaaand done! Now we can navigate from 1 view to another without the <code>NavigationLink</code> in the view itself.</p><p>Ok, but what if I want to present the view as a modal, as we said before? Well, I have a small trick for that, which is wrapping <code>sheet</code> in a View:</p><pre><code><span class="la-keyword">struct</span> ModalReturnWrapper&lt;T: <span class="la-type">View</span>&gt;: <span class="la-type">ReturnWrapper</span> {
    <span class="la-keyword">typealias</span> DestinationView = <span class="la-type">T</span>
    
    <span class="la-keyword">@Binding var</span> isPresented: <span class="la-type">Bool</span>
    <span class="la-keyword">var</span> destination: <span class="la-type">T</span>
    
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">EmptyView</span>()
            .<span class="la-call">sheet</span>(isPresented: $isPresented, content: {
                <span class="la-keyword">self</span>.<span class="la-property">destination</span>
            })
    }
}
</code></pre><p>Now we can go to <code>NavigationDetailCoordinator</code> and change the implementation of <code>start()</code> to show the view as a modal instead of a push on the navigation stack, like this:</p><pre><code><span class="la-keyword">final class</span> NavigationDetailCoordinator: <span class="la-type">Coordinator</span> {
    <span class="la-keyword">private var</span> isPresented: <span class="la-type">Binding</span>&lt;<span class="la-type">Bool</span>&gt;
    
    <span class="la-keyword">init</span>(isPresented: <span class="la-type">Binding</span>&lt;<span class="la-type">Bool</span>&gt;) {
        <span class="la-keyword">self</span>.<span class="la-property">isPresented</span> = isPresented
    }
    
    <span class="la-keyword">func</span> start() -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">return</span> <span class="la-type">NavigationReturnWrapper</span>(isPresented: isPresented, destination: view)
    }
}
</code></pre><p>That's it! That's the change, we didn't have to touch <code>MasterView</code> or any other view.</p><p>Since we'll likely need to identify the coordinators and have access to their parents, let's go back to the <code>Coordinator</code> protocol and see how we can create stored properties. I have to confess I used a trick, I used the Objective-C runtime to store them, creating a <em>mixin</em>:</p><pre><code><span class="la-keyword">protocol</span> Coordinator: <span class="la-type">AssociatedObject</span> { <span class="la-comment">// notice AssociatedObject conformance</span>
    <span class="la-keyword">associatedtype</span> U: <span class="la-type">View</span>
    <span class="la-keyword">associatedtype</span> P: <span class="la-type">Coordinator</span>
    <span class="la-keyword">func</span> start() -&gt; <span class="la-type">U</span>
}

<span class="la-keyword">extension</span> <span class="la-type">Coordinator</span> { <span class="la-comment">// Mixin Extension</span>
    <span class="la-keyword">fileprivate var</span> identifier: <span class="la-type">UUID</span> {
        <span class="la-keyword">get</span> {
            <span class="la-keyword">guard let</span> identifier: <span class="la-type">UUID</span> = <span class="la-call">associatedObject</span>(for: &amp;identifierKey) <span class="la-keyword">else</span> {
                <span class="la-keyword">self</span>.<span class="la-property">identifier</span> = <span class="la-type">UUID</span>()
                <span class="la-keyword">return self</span>.<span class="la-property">identifier</span>
            }
            <span class="la-keyword">return</span> identifier
        }
        <span class="la-keyword">set</span> {
            <span class="la-call">setAssociatedObject</span>(newValue, for: &amp;identifierKey)
        }
    }
    
    <span class="la-keyword">var</span> parent: <span class="la-type">P</span>? {
        <span class="la-keyword">get</span> { <span class="la-call">associatedObject</span>(for: &amp;parentKey) }
        <span class="la-keyword">set</span> { <span class="la-call">setAssociatedObject</span>(newValue, for: &amp;parentKey) }
    }
    
    <span class="la-keyword">func</span> coordinate&lt;T: <span class="la-type">Coordinator</span>&gt;(to coordinator: <span class="la-type">T</span>) -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">_</span> = coordinator.<span class="la-property">identifier</span> <span class="la-comment">// generate identifier</span>
        coordinator.<span class="la-property">parent</span> = <span class="la-keyword">self as</span>? <span class="la-type">T</span>.<span class="la-type">P</span>
        <span class="la-keyword">return</span> coordinator.<span class="la-call">start</span>()
    }
}
</code></pre><p>What's a <em>mixin</em>? Well, <a href="https://jobandtalent.engineering/the-power-of-mixins-in-swift-f9013254c503">my friend Luis explains it better than me on this blog post</a>. But long story short, they are a way of leveraging on composition instead of subclassing.</p><p>Now that we have stored properties in the protocol extension, we can store the identifier and parent of the protocol, leveraging again on generics.</p><p>This last change to the protocol impacts on the coordinators again, and we have to make small changes to them in order to conform to <code>Coordinator</code>.</p><p>I invite you to <a href="https://github.com/Lascorbe/SwiftUI-MVP-Coordinator">take a look at the project I created</a>, where the final implementation is, with more classes and examples, and both ways of navigating, with navigation stack and modals. There you can also take a look at <code>AssociatedObject.swift</code> and see how we can create stored properties under the hood.</p><p>After all, there're a few considerations I wonder, and I would like you to know:</p><ul><li>I didn't implement a way to navigate back from a coordinator, should there be one?</li><li>Is this a good approach? Or the declarative nature of SwiftUI pushes us to use other design pattern/architecture?</li></ul><p>I hope you liked those 2 post covering my experience trying to decouple the navigation on SwftUI. Let me know what you think and share it with your friends!</p></div></div><div class="post-description"><div class="pure-u-md-1-1"><a href="https://twitter.com/intent/tweet?via=lascorbe&text=MVP%20+%20Coordinators%20in%20SwiftUI%20(part%202)&url=https://lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part2" target="_blank"><i class="fab fa-twitter l-box social-icon"></i>Share this post on Twitter.</a></div></div></div><div class="footer pure-u-1"><div class="pure-u-1">© 2020 Luis Ascorbe</div><div class="pure-u-1">Generated using <a href="https://github.com/johnsundell/publish" target="_blank">Publish</a>. 100% JavaScript-free.</div><div class="pure-u-1"><a href="/feed.rss">RSS</a> | <a href="/about">About</a></div></div></div></body></html>