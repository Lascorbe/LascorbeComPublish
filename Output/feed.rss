<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Luis Ascorbe</title><description>Software Developer. Tech Lead. Speaker. Conference Organizer.</description><link>https://lascorbe.com</link><language>en</language><lastBuildDate>Mon, 27 Apr 2020 03:35:05 +0200</lastBuildDate><pubDate>Mon, 27 Apr 2020 03:35:05 +0200</pubDate><ttl>250</ttl><atom:link href="https://lascorbe.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part2</guid><title>MVP + Coordinators in SwiftUI (part 2)</title><description>2nd part of exploring a MVP+Coordinators approach on SwiftUI without using UIKit.</description><link>https://lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part2</link><pubDate>Mon, 27 Apr 2020 13:00:00 +0200</pubDate><content:encoded><![CDATA[<img src="https://lascorbe.com/images/posts/2020-04-26-MVPCoordinators-SwiftUI/1.jpg"/><p><em>Public repo: For those of you who want to check out the code right away here is the repo: <a href="https://github.com/Lascorbe/SwiftUI-MVP-Coordinator">https://github.com/Lascorbe/SwiftUI-MVP-Coordinator</a>.</em></p><p>This is the 2nd part of the blog posts on creating an MVP+Coordinators app with SwiftUI. If you're looking for the 1st part, please go here: <a href="https://lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part1">lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part1</a></p><p>The last thing we did in <em>part 1</em> was moving <code>NavigationView</code> out of the <code>MasterView</code> and "hidding" <code>NavigationLink</code> as the background view of the Button's text:</p><pre><code><span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">MasterPresenting</span>
  
    <span class="la-keyword">@State private var</span> isPresented = <span class="la-keyword">false
  
    var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">Button</span>(action: {
            <span class="la-keyword">self</span>.<span class="la-property">isPresented</span> = <span class="la-keyword">true</span>
        }) {
            <span class="la-type">Text</span>(<span class="la-string">"</span>\(viewModel.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>) 
                .<span class="la-call">background</span>(
                    <span class="la-type">NavigationLink</span>(destination: <span class="la-type">EmptyView</span>(), isActive: $isPresented) {
                        <span class="la-type">EmptyView</span>()
                    }
                )
        }
    }
}
</code></pre><p>Now we can extract <code>NavigationLink</code>, so the button in <code>MasterView</code> will look like this:</p><pre><code><span class="la-type">Button</span>(action: {
    <span class="la-keyword">self</span>.<span class="la-property">isPresented</span> = <span class="la-keyword">true</span>
}) {
    <span class="la-type">Text</span>(<span class="la-string">"</span>\(viewModel.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>) 
        .<span class="la-call">background</span>(
				    <span class="la-keyword">self</span>.<span class="la-property">presenter</span>.<span class="la-call">onButtonPressed</span>(isPresented: $isPresented)
        )
}
</code></pre><p>See how we switched <code>NavigationLink</code> with a presenter's function. And now I ask, where do we move <code>NavigationLink</code> to? The presenter? Nop! To the coordinator! But first, let's implement this method in the presenter:</p><pre><code><span class="la-keyword">protocol</span> MasterPresenting: <span class="la-type">ObservableObject</span> {
    <span class="la-keyword">associatedtype</span> U: <span class="la-type">View</span>                                
    <span class="la-keyword">var</span> viewModel: <span class="la-type">MasterViewModel</span> { <span class="la-keyword">get</span> }
    <span class="la-keyword">func</span> onButtonPressed(isPresented: <span class="la-type">Binding</span>&lt;<span class="la-type">Bool</span>&gt;) -&gt; <span class="la-type">U</span> <span class="la-comment">// we return a</span> 
}

<span class="la-keyword">final class</span> MasterPresenter: <span class="la-type">MasterPresenting</span> {
    <span class="la-keyword">@Published private(set) var</span> viewModel: <span class="la-type">MasterViewModel</span>
  
    <span class="la-keyword">private let</span> coordinator: <span class="la-type">MasterCoordinator</span>
    
    <span class="la-keyword">init</span>(coordinator: <span class="la-type">MasterCoordinator</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">coordinator</span> = coordinator
    }
  
    <span class="la-keyword">func</span> onButtonPressed(isPresented: <span class="la-type">Binding</span>&lt;<span class="la-type">Bool</span>&gt;) -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> { <span class="la-comment">// using `some` we don't have to specify the MasterPresenting's associatedtype</span>
        <span class="la-keyword">return</span> coordinator.<span class="la-call">presentDetailView</span>(isPresented: isPresented)
    }
}
</code></pre><p>We have to return a SwiftUI View, which can only be used as a generic constraint, so we need to specify an <code>associatedtype</code> in our <code>MasterPresenting</code> protocol. Notice how with the <code>some</code> keyword we don't have to specify the <code>associatedtype</code>.</p><p>Also look at <code>coordinator.presentDetailView</code>, it's returning a View. We're going there next but first we have to modify our <code>MasterView</code> because is using a generic protocol now:</p><pre><code><span class="la-keyword">struct</span> MasterView&lt;T: <span class="la-type">MasterPresenting</span>&gt;: <span class="la-type">View</span> { <span class="la-comment">// `T` arrived!</span>
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">T</span>
  
    {...}
}
</code></pre><p>Since we don't want <code>MasterView</code> to know what <code>MasterPresenting</code> we're injecting, let's tell it on construction.</p><p>Now we can go to our coordinator and add the <code>presentDetailView</code> function. Remember we had a <code>MasterCoordinator</code> protocol which was empty? Not anymore:</p><pre><code><span class="la-keyword">protocol</span> MasterCoordinator: <span class="la-type">Coordinator</span> {}

<span class="la-keyword">extension</span> <span class="la-type">MasterCoordinator</span>: <span class="la-type">Coordinator</span> {
    <span class="la-keyword">func</span> presentDetailView(isPresented: <span class="la-type">Binding</span>&lt;<span class="la-type">Bool</span>&gt;) -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">let</span> coordinator = <span class="la-type">NavigationDetailCoordinator</span>(isPresented: isPresented)
        <span class="la-keyword">return</span> <span class="la-call">coordinate</span>(to: coordinator)
    }
}
</code></pre><p>Since <code>presentDetailView</code> is a <em>pure</em> function, we can add it to the <code>MasterCoordinator</code> protocol's extension.</p><p>Notice that we have a new coordinator, <code>NavigationDetailCoordinator</code>, it's exactly where we're going to put the <code>NavigationLink</code>:</p><pre><code><span class="la-keyword">final class</span> NavigationDetailCoordinator: <span class="la-type">Coordinator</span> {
    <span class="la-keyword">private var</span> isPresented: <span class="la-type">Binding</span>&lt;<span class="la-type">Bool</span>&gt;
    
    <span class="la-keyword">init</span>(isPresented: <span class="la-type">Binding</span>&lt;<span class="la-type">Bool</span>&gt;) {
        <span class="la-keyword">self</span>.<span class="la-property">isPresented</span> = isPresented
    }
    
    <span class="la-keyword">func</span> start() -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">return</span> <span class="la-type">NavigationLink</span>(destination: <span class="la-type">EmptyView</span>(), isActive: isPresented) {
            <span class="la-type">EmptyView</span>()
        }
    }
}
</code></pre><p>Great! Hmmm but now we have a problem, we're returning a View from <code>start()</code>, but the <code>Coordinator</code> protocol implementation is not returning anything.</p><p>Let's change it then, this is our new <code>Coordinator</code>:</p><pre><code><span class="la-keyword">protocol</span> Coordinator {
    <span class="la-keyword">associatedtype</span> U: <span class="la-type">View</span>
    <span class="la-keyword">func</span> start() -&gt; <span class="la-type">U</span>
}

<span class="la-keyword">extension</span> <span class="la-type">Coordinator</span> {
    <span class="la-keyword">func</span> coordinate&lt;T: <span class="la-type">Coordinator</span>&gt;(to coordinator: <span class="la-type">T</span>) -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">return</span> coordinator.<span class="la-call">start</span>()
    }
}
</code></pre><p>Ok, we redo our <code>start</code> and <code>coordinate</code> methods, now both of them return a View. We rely on the power of generics and the keyword <code>some</code> to avoid specifying them.</p><p>Since we're now relying on a generic protocol for the coordinators, we have to change the implementation of the <code>AppCoordinator</code>, <code>MasterFactory</code> and <code>MasterPresenter</code> like so:</p><pre><code><span class="la-keyword">final class</span> AppCoordinator: <span class="la-type">Coordinator</span> {
    {...}
    
    <span class="la-keyword">func</span> start() -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">let</span> coordinator = <span class="la-type">NavigationMasterCoordinator</span>(window: window)
        <span class="la-keyword">return</span> coordinator.<span class="la-call">coordinate</span>(to: coordinator)
    }
}

<span class="la-keyword">final class</span> RootMasterCoordinator: <span class="la-type">MasterCoordinator</span> {
    {...}
    
    <span class="la-keyword">func</span> start() -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">let</span> view = <span class="la-type">MasterFactory</span>.<span class="la-call">make</span>(with: <span class="la-keyword">self</span>)
        <span class="la-keyword">let</span> navigation = <span class="la-type">NavigationView</span> { view }
        <span class="la-keyword">let</span> hosting = <span class="la-type">UIHostingController</span>(rootView: navigation)
        window?.<span class="la-property">rootViewController</span> = hosting
        window?.<span class="la-call">makeKeyAndVisible</span>()
        <span class="la-keyword">return</span> <span class="la-type">EmptyView</span>() <span class="la-comment">// we just have to return something</span>
    }
}

<span class="la-keyword">enum</span> MasterFactory {
    <span class="la-keyword">static func</span> make&lt;C: <span class="la-type">MasterCoordinator</span>&gt;(with coordinator: <span class="la-type">C</span>) -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        {...}
    }
}

<span class="la-keyword">final class</span> MasterPresenter&lt;C: <span class="la-type">MasterCoordinator</span>&gt;: <span class="la-type">MasterPresenting</span> {
    <span class="la-keyword">@Published private(set) var</span> viewModel: <span class="la-type">MasterViewModel</span>
  
    <span class="la-keyword">private let</span> coordinator: <span class="la-type">C</span>
    
    <span class="la-keyword">init</span>(coordinator: <span class="la-type">C</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">coordinator</span> = coordinator
    }
  
    {...}
}
</code></pre><p>Check out the <code>some View</code> and <code>&lt;C: MasterCoordinator&gt;</code> parts, we are just conforming to the <code>Coordinator</code> protocol.</p><p>Aaaand done! Now we can navigate from 1 view to another without the <code>NavigationLink</code> in the view itself.</p><p>Ok, but what if I want to present the view as a modal, as we said before? Well, I have a small trick for that, which is wrapping <code>sheet</code> in a View:</p><pre><code><span class="la-keyword">struct</span> ModalReturnWrapper&lt;T: <span class="la-type">View</span>&gt;: <span class="la-type">ReturnWrapper</span> {
    <span class="la-keyword">typealias</span> DestinationView = <span class="la-type">T</span>
    
    <span class="la-keyword">@Binding var</span> isPresented: <span class="la-type">Bool</span>
    <span class="la-keyword">var</span> destination: <span class="la-type">T</span>
    
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">EmptyView</span>()
            .<span class="la-call">sheet</span>(isPresented: $isPresented, content: {
                <span class="la-keyword">self</span>.<span class="la-property">destination</span>
            })
    }
}
</code></pre><p>Now we can go to <code>NavigationDetailCoordinator</code> and change the implementation of <code>start()</code> to show the view as a modal instead of a push on the navigation stack, like this:</p><pre><code><span class="la-keyword">final class</span> NavigationDetailCoordinator: <span class="la-type">Coordinator</span> {
    <span class="la-keyword">private var</span> isPresented: <span class="la-type">Binding</span>&lt;<span class="la-type">Bool</span>&gt;
    
    <span class="la-keyword">init</span>(isPresented: <span class="la-type">Binding</span>&lt;<span class="la-type">Bool</span>&gt;) {
        <span class="la-keyword">self</span>.<span class="la-property">isPresented</span> = isPresented
    }
    
    <span class="la-keyword">func</span> start() -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">return</span> <span class="la-type">NavigationReturnWrapper</span>(isPresented: isPresented, destination: view)
    }
}
</code></pre><p>That's it! That's the change, we didn't have to touch <code>MasterView</code> or any other view.</p><p>Since we'll likely need to identify the coordinators and have access to their parents, let's go back to the <code>Coordinator</code> protocol and see how we can create stored properties. I have to confess I used a trick, I used the Objective-C runtime to store them, creating a <em>mixin</em>:</p><pre><code><span class="la-keyword">protocol</span> Coordinator: <span class="la-type">AssociatedObject</span> { <span class="la-comment">// notice AssociatedObject conformance</span>
    <span class="la-keyword">associatedtype</span> U: <span class="la-type">View</span>
    <span class="la-keyword">associatedtype</span> P: <span class="la-type">Coordinator</span>
    <span class="la-keyword">func</span> start() -&gt; <span class="la-type">U</span>
}

<span class="la-keyword">extension</span> <span class="la-type">Coordinator</span> { <span class="la-comment">// Mixin Extension</span>
    <span class="la-keyword">fileprivate var</span> identifier: <span class="la-type">UUID</span> {
        <span class="la-keyword">get</span> {
            <span class="la-keyword">guard let</span> identifier: <span class="la-type">UUID</span> = <span class="la-call">associatedObject</span>(for: &amp;identifierKey) <span class="la-keyword">else</span> {
                <span class="la-keyword">self</span>.<span class="la-property">identifier</span> = <span class="la-type">UUID</span>()
                <span class="la-keyword">return self</span>.<span class="la-property">identifier</span>
            }
            <span class="la-keyword">return</span> identifier
        }
        <span class="la-keyword">set</span> {
            <span class="la-call">setAssociatedObject</span>(newValue, for: &amp;identifierKey)
        }
    }
    
    <span class="la-keyword">var</span> parent: <span class="la-type">P</span>? {
        <span class="la-keyword">get</span> { <span class="la-call">associatedObject</span>(for: &amp;parentKey) }
        <span class="la-keyword">set</span> { <span class="la-call">setAssociatedObject</span>(newValue, for: &amp;parentKey) }
    }
    
    <span class="la-keyword">func</span> coordinate&lt;T: <span class="la-type">Coordinator</span>&gt;(to coordinator: <span class="la-type">T</span>) -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">_</span> = coordinator.<span class="la-property">identifier</span> <span class="la-comment">// generate identifier</span>
        coordinator.<span class="la-property">parent</span> = <span class="la-keyword">self as</span>? <span class="la-type">T</span>.<span class="la-type">P</span>
        <span class="la-keyword">return</span> coordinator.<span class="la-call">start</span>()
    }
}
</code></pre><p>What's a <em>mixin</em>? Well, <a href="https://jobandtalent.engineering/the-power-of-mixins-in-swift-f9013254c503">my friend Luis explains it better than me on this blog post</a>. But long story short, they are a way of leveraging on composition instead of subclassing.</p><p>Now that we have stored properties in the protocol extension, we can store the identifier and parent of the protocol, leveraging again on generics.</p><p>This last change to the protocol impacts on the coordinators again, and we have to make small changes to them in order to conform to <code>Coordinator</code>.</p><p>I invite you to <a href="https://github.com/Lascorbe/SwiftUI-MVP-Coordinator">take a look at the project I created</a>, where the final implementation is, with more classes and examples, and both ways of navigating, with navigation stack and modals. There you can also take a look at <code>AssociatedObject.swift</code> and see how we can create stored properties under the hood.</p><p>After all, there're a few considerations I wonder, and I would like you to know:</p><ul><li>I didn't implement a way to navigate back from a coordinator, should there be one?</li><li>Is this a good approach? Or the declarative nature of SwiftUI pushes us to use other design pattern/architecture?</li></ul><p>I hope you liked those 2 post covering my experience trying to decouple the navigation on SwftUI. Let me know what you think and share it with your friends!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part1</guid><title>MVP + Coordinators in SwiftUI (part 1)</title><description>1st part of exploring a MVP+Coordinators approach on SwiftUI without using UIKit.</description><link>https://lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part1</link><pubDate>Mon, 27 Apr 2020 12:00:00 +0200</pubDate><content:encoded><![CDATA[<img src="https://lascorbe.com/images/posts/2020-04-26-MVPCoordinators-SwiftUI/1.jpg"/><p><em>Public repo: For those of you who want to check out the code right away here is the repo: <a href="https://github.com/Lascorbe/SwiftUI-MVP-Coordinator">https://github.com/Lascorbe/SwiftUI-MVP-Coordinator</a>.</em></p><p><strong>I didn't want to do much on SwiftUI until the next version is announced</strong> due to my previous experience with Swift, I mean, I'll likely introduce a lot of breaking changes. I still remember the pain of migrating between Swift versions (Swift 3 to 4 anyone?), and I didn't want to live that again.</p><p>But all changed, quarantine arrived and I wanted to give a hand building a new app for a friend. I thought it could be nice to try SwiftUI making a real app. What a great tool it is, <strong>something that took you 2 days to do with UIKit now you can do it in 2 hours</strong>, it just boosts development so much, it's what we all were waiting for while we were looking at things like hot reloading of our frontend colleagues, or React Native or Flutter... Plus a declarative layout. Great!</p><p>In SwiftUI everything is a land of unicorns until you discover that not only navigation is a bit tied to the views, but <a href="https://twitter.com/Dimillian/status/1184745928739184640?s=20">there're</a> <a href="https://twitter.com/tomatoterrorist/status/1242823885621350401?s=20">some</a> <a href="https://twitter.com/SwiftUILab/status/1156091686151475200?s=20">broken</a> <a href="https://twitter.com/ishabazz/status/1234274177231638529?s=20">things</a> <a href="https://twitter.com/search?q=broken%20swiftui&src=typed_query">between iOS 13 minor versions</a> and other platforms.</p><p>I can't do much about how broken an Apple framework/tool is (above reporting <s>radars</s> <a href="https://feedbackassistant.apple.com">feedbacks</a>), but I can explore <strong>how navigation can be decoupled from Views</strong>, or at least I can try. Also, <a href="https://twitter.com/Lascorbe/status/1253992068814430209?s=20">looks like there's some interest</a>.</p><p>I choose MVP and <a href="https://khanlou.com/2015/10/coordinators-redux/">Coordinators</a>, because I've worked with both, and because Coordinators became the defacto design pattern to route our navigation on a UIKit app. I don't know if those 2 are the best design patterns to use with SwiftUI, maybe not, maybe something like redux would fit better, I don't know, but it doesn't hurt to try (I also want to try redux btw).</p><p>I'm not going to explain how coordinators work, <a href="https://khanlou.com/2015/10/coordinators-redux/">there're</a> <a href="https://www.hackingwithswift.com/articles/175/advanced-coordinator-pattern-tutorial-ios">several</a> <a href="https://khanlou.com/tag/advanced-coordinators/">blog posts</a> far better and from smarter people than me which I recommend you to check out if you haven't.</p><p>Cool, are you ready? Then let's go for it! Let's define the 1st view of our app:</p><pre><code><span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">Text</span>(<span class="la-string">"We will rock the stage at NSSpain again"</span>)
    }
}
</code></pre><p>I really want to try to void words like "just", "easy", "simple", "complex"... but this really is <em>just</em> one label in the middle of the screen.</p><p>Now the model, <em>just</em> storing a date (I'll call them ViewModels because we're at the UI layer):</p><pre><code><span class="la-keyword">struct</span> MasterViewModel {
    <span class="la-keyword">let</span> date: <span class="la-type">Date</span>
}
</code></pre><p>Now the presenter:</p><pre><code><span class="la-keyword">protocol</span> MasterPresenting: <span class="la-type">ObservableObject</span> { <span class="la-comment">// Notice conformance to ObservableObject</span>
    <span class="la-keyword">var</span> viewModel: <span class="la-type">MasterViewModel</span> { <span class="la-keyword">get</span> }
}

<span class="la-keyword">final class</span> MasterPresenter: <span class="la-type">MasterPresenting</span> {
    <span class="la-keyword">@Published private(set) var</span> viewModel: <span class="la-type">MasterViewModel</span>
}
</code></pre><p>Yes, we're doing protocols all the way. This is going to be a small app, but let's treat it as if it was a big one. We declare the protocol of the presenter, so we can inject it in our view, which will make things like testing easier.</p><p>We declare the protocol as <code>ObservableObject</code> so we can observe the <code>@Published</code> properties from the view. Let's change our view to adopt this:</p><pre><code><span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">MasterPresenting</span>
  
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">Text</span>(<span class="la-string">"</span>\(viewModel.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>)
    }
}
</code></pre><p>To bind this view to the presenter we need the <code>@ObservedObject</code> property wrapper. <code>dateFormatter</code> is just a global <code>DateFormatter</code> defined somewhere else. Now our view is "listening" for whenever our <code>viewModel</code> changes!</p><p>We have the MVP, and we're going to define our coordinator now. So how does our base Coordinator look like?</p><pre><code><span class="la-keyword">protocol</span> Coordinator {
    <span class="la-keyword">func</span> start()
}
</code></pre><p>Let's start with something like this. And we extend the protocol to define a coordinate function:</p><pre><code><span class="la-keyword">extension</span> <span class="la-type">Coordinator</span> {
    <span class="la-keyword">func</span> coordinate(to coordinator: <span class="la-type">Coordinator</span>) {
        coordinator.<span class="la-property">parent</span> = <span class="la-keyword">self</span>
        childs[coordinator.<span class="la-property">identifier</span>] = coordinator
        coordinator.<span class="la-call">start</span>()
    }
}
</code></pre><p>Wait, how are you storing parent and childs on a protocol extension? Bear with me for a moment, we'll get there.</p><p>Next, we can try to implement <code>MasterView</code>'s coordinator:</p><pre><code><span class="la-keyword">protocol</span> MasterCoordinator: <span class="la-type">Coordinator</span> {} <span class="la-comment">// empty for now</span>

<span class="la-keyword">final class</span> RootMasterCoordinator: <span class="la-type">MasterCoordinator</span> {
    <span class="la-keyword">func</span> start() {
        ??
    }
}
</code></pre><p>Hmmm, what can we do here? Let's go to the beginning of the app, the <code>SceneDelegate</code>, and see what we need to get here.</p><pre><code><span class="la-keyword">func</span> scene(<span class="la-keyword">_</span> scene: <span class="la-type">UIScene</span>, willConnectTo session: <span class="la-type">UISceneSession</span>, options connectionOptions: <span class="la-type">UIScene</span>.<span class="la-type">ConnectionOptions</span>) {
    <span class="la-keyword">if let</span> windowScene = scene <span class="la-keyword">as</span>? <span class="la-type">UIWindowScene</span> {
        <span class="la-keyword">let</span> window = <span class="la-type">UIWindow</span>(windowScene: windowScene)
        <span class="la-keyword">let</span> coordinator = <span class="la-type">AppCoordinator</span>(window: window) <span class="la-comment">// &lt;-- look here</span>
        coordinator.<span class="la-call">start</span>()                              <span class="la-comment">// &lt;-- and here</span>
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
}
</code></pre><p>The important part is the 2 lines of the coordinator, the initialization, where we inject the window, and <code>coordinator.start()</code>. Now let's define our <code>AppCoordinator</code>, which is going to be the starting point of the app navigation:</p><pre><code><span class="la-keyword">final class</span> AppCoordinator: <span class="la-type">Coordinator</span> {
    <span class="la-keyword">private(set) weak var</span> window: <span class="la-type">UIWindow</span>?
    
    <span class="la-keyword">init</span>(window: <span class="la-type">UIWindow</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
    
    <span class="la-keyword">func</span> start() {
        <span class="la-keyword">let</span> coordinator = <span class="la-type">NavigationMasterCoordinator</span>(window: window)
        <span class="la-keyword">return</span> coordinator.<span class="la-call">coordinate</span>(to: coordinator)
    }
}
</code></pre><p>Next, we have to handle the presentation on the window. Let's go back to our <code>RootMasterCoordinator</code> and set up the <code>start()</code> function:</p><pre><code><span class="la-keyword">final class</span> RootMasterCoordinator: <span class="la-type">MasterCoordinator</span> {
    <span class="la-keyword">private(set) weak var</span> window: <span class="la-type">UIWindow</span>?
    
    <span class="la-keyword">init</span>(window: <span class="la-type">UIWindow</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
    
    <span class="la-keyword">func</span> start() {
        <span class="la-keyword">let</span> view = <span class="la-type">MasterFactory</span>.<span class="la-call">make</span>(with: <span class="la-keyword">self</span>)
        <span class="la-keyword">let</span> hosting = <span class="la-type">UIHostingController</span>(rootView: view)
        window?.<span class="la-property">rootViewController</span> = hosting
        window?.<span class="la-call">makeKeyAndVisible</span>()
    }
}
</code></pre><p>Here we just take the window and present the <code>rootViewController</code> (<code>UIHostingController</code> is what you need to bring SwiftUI Views to UIKit). The <code>AppCoordinator</code> and the <code>RootMasterCoordinator</code> are the only 2 coordinators where we need UIKit, maybe in <em>June</em> we get a new <code>UISceneDelegate</code>/<code>UIApplicationDelegate</code> API?</p><p>There's an interesting line in <code>RootMasterCoordinator</code>, what's behind that <code>MasterFactory</code>? As you can guess, just a factory:</p><pre><code><span class="la-keyword">enum</span> MasterFactory {
    <span class="la-keyword">static func</span> make(with coordinator: <span class="la-type">Coordinator</span>) -&gt; <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-keyword">let</span> presenter = <span class="la-type">MasterPresenter</span>(coordinator: coordinator)
        <span class="la-keyword">let</span> view = <span class="la-type">MasterView</span>(presenter: presenter)
        <span class="la-keyword">return</span> view
    }
}
</code></pre><p>I'm using an <code>enum</code> so it cannot be initialized, but a <code>struct</code> with an unavailable init also works. Here we get an interesting bit, notice we're returning <code>some View</code>, so we can get the SwiftUI view in <code>RootMasterCoordinator</code>.</p><p>Also, looks like now we're injecting our coordinator into the presenter, in <code>MasterPresenter(coordinator: coordinator)</code>, so let's implement that too:</p><pre><code><span class="la-keyword">final class</span> MasterPresenter: <span class="la-type">MasterPresenting</span> {
    <span class="la-keyword">@Published private(set) var</span> viewModel: <span class="la-type">MasterViewModel</span>
  
    <span class="la-keyword">private let</span> coordinator: <span class="la-type">MasterCoordinator</span>
    
    <span class="la-keyword">init</span>(coordinator: <span class="la-type">MasterCoordinator</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">coordinator</span> = coordinator
        <span class="la-comment">// You may want to bind your viewModel to a service/DB here, maybe using Combine/RxSwift</span>
    }
}
</code></pre><p>As you can see, we inject the coordinator through the init as we did with the window, then you may want to bind your model/entity.</p><p>Now that we have the base structure of the UI, we can see how we can navigate to a view. Let's go back to <code>MasterView</code>, and try to see how we can navigate to another view.</p><pre><code><span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">MasterPresenting</span>
  
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">NavigationView</span> {
            <span class="la-type">NavigationLink</span>(destination: <span class="la-type">EmptyView</span>()) {
                <span class="la-type">Text</span>(<span class="la-string">"</span>\(viewModel.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>)  
            }
        }
    }
}
</code></pre><p>Ok, what's going on. We're telling <code>MasterView</code> that its content is wrapped in a <code>NavigationView</code>, kind of a <code>UINavigationController</code>. Then with <code>NavigationLink</code>, we create a <code>push</code> action to <code>EmptyView()</code> which is going to be shown when <code>Text</code> is pressed.</p><p>But we don't want either <code>MasterView</code> to know that is being presented in a <code>NavigationView</code>, or that we're presenting <code>EmptyView()</code>, or that it must use <code>NavigationLink</code> to present it.</p><p>First, we're going to move <code>NavigationView</code> out, the place where it should go? Yup, the coordinator:</p><pre><code><span class="la-keyword">final class</span> RootMasterCoordinator: <span class="la-type">MasterCoordinator</span> {
    <span class="la-keyword">private(set) weak var</span> window: <span class="la-type">UIWindow</span>?
    
    <span class="la-keyword">init</span>(window: <span class="la-type">UIWindow</span>) {
        <span class="la-keyword">self</span>.<span class="la-property">window</span> = window
    }
    
    <span class="la-keyword">func</span> start() {
        <span class="la-keyword">let</span> view = <span class="la-type">MasterFactory</span>.<span class="la-call">make</span>(with: <span class="la-keyword">self</span>)
        <span class="la-keyword">let</span> navigation = <span class="la-type">NavigationView</span> { view } <span class="la-comment">// Hi! I'm new</span>
        <span class="la-keyword">let</span> hosting = <span class="la-type">UIHostingController</span>(rootView: navigation)
        window?.<span class="la-property">rootViewController</span> = hosting
        window?.<span class="la-call">makeKeyAndVisible</span>()
    }
}

<span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">MasterPresenting</span>
  
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-comment">// NavigationView is no longer here</span>
        <span class="la-type">NavigationLink</span>(destination: <span class="la-type">EmptyView</span>()) {
            <span class="la-type">Text</span>(<span class="la-string">"</span>\(viewModel.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>)  
        }
    }
}
</code></pre><p>Better. Next, we're going to move <code>NavigationLink</code> from there, it should be a function we can call on the presenter, something like:</p><pre><code><span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">MasterPresenting</span>
  
    <span class="la-keyword">var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        presenter.<span class="la-call">presentSuperAmazingView</span> {
            <span class="la-type">Text</span>(<span class="la-string">"</span>\(viewModel.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>)  
        }
    }
}
</code></pre><p>But there're 2 problems here. One, it's hard to understand what <code>presentSuperAmazingView</code> does, does it make <code>Text</code> a button? will it push the view? Second, we're working with <code>NavigationLink</code>, but what happens if we want to present a modal? The way to present a modal is with a view modifier called <code>.sheet</code>.</p><p>That's right, to push a view we have a View struct, <code>NavigationView</code>, and to present a modal we have a modifier, <code>.sheet</code>. If there's something I truly want to avoid is the lack of consistency. Maybe I'm too dumb to understand why it's been done like this, but I'm my humble opinion they both should work the same way (and I don't care if it's with structs or modifiers, but use the same thing). So please, please, if you're an Apple Engineer reading this, for the sake of consistency, expose them both the same way, thank you.</p><p>Anyway, how can we avoid this nicely? The best way I found is <a href="https://stackoverflow.com/a/61188788/736384">using a <code>.background</code> view inside a Button's content</a>. It's better to see it in code, so now our <code>MasterView</code> looks like this:</p><pre><code><span class="la-keyword">struct</span> MasterView: <span class="la-type">View</span> {
    <span class="la-keyword">@ObservedObject var</span> presenter: <span class="la-type">MasterPresenting</span>
  
    <span class="la-keyword">@State private var</span> isPresented = <span class="la-keyword">false
  
    var</span> body: <span class="la-keyword">some</span> <span class="la-type">View</span> {
        <span class="la-type">Button</span>(action: {
            <span class="la-keyword">self</span>.<span class="la-property">isPresented</span> = <span class="la-keyword">true</span>
        }) {
            <span class="la-type">Text</span>(<span class="la-string">"</span>\(viewModel.<span class="la-property">date</span>, formatter: dateFormatter)<span class="la-string">"</span>) 
                .<span class="la-call">background</span>(
                    <span class="la-comment">// this is the cool part</span>
                    <span class="la-type">NavigationLink</span>(destination: <span class="la-type">EmptyView</span>(), isActive: $isPresented) {
                        <span class="la-type">EmptyView</span>()
                    }
                )
        }
    }
}
</code></pre><p>Wooooow, ok, it looks weird, but it works. Essentially we're hiding the <code>NavigationLink</code> in the Button's text background, and the way it works is through <code>isActive</code>, whenever the button is pressed, it'll switch <code>isPresented</code> to <code>true</code> which will trigger the <code>NavigationLink</code>.</p><p>Thank you for reading, I hope you liked it. This ends part 1, follow up to part 2 here: <a href="https://lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part2">lascorbe.com/posts/2020-04-27-MVPCoordinators-SwiftUI-part2</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://lascorbe.com/posts/2020-04-21-hello-world</guid><title>Hello world!</title><description>Hi there from the trenches! üëã</description><link>https://lascorbe.com/posts/2020-04-21-hello-world</link><pubDate>Tue, 21 Apr 2020 13:00:00 +0200</pubDate><content:encoded><![CDATA[<p>Hi there!</p><p>Welcome to my new blog. Thank you for wasting your time reading me, I mean, I'm pretty sure there's a new Netflix documentary that you haven't seen way more interesting than reading what an average human being from Spain could write. So thank you for reading üòä.<br><br>Why I made this? This is my 3rd or 4th attempt at trying to start a blog. I hope to be more consistent and write often. The good thing is that this is the first time I make a blog by myself, on my domain (years ago I used Blogger and Medium). So let's see how this goes üòÉ.</p><p>What about the content? I'm not completely sure if this is going to be a purely technical blog or I'm going to write about other things, I'll figure it out while driving. Anyway, for now, the topics will be mostly technical, I'm exploring SwiftUI so I think that's what I'm going to start with.</p><p>What about how I made this website? I made it entirely with <a href="https://github.com/JohnSundell/Publish">Publish</a>, a great tool to make websites with Swift, by my buddy <a href="https://twitter.com/JohnSundell">John Sundell</a>. Check it out, it's modular and versatile, John did an amazing job building it.</p><p>If you want to know how to make your website with <a href="https://github.com/JohnSundell/Publish">Publish</a>, 2 articles helped me to get started:</p><ul><li><a href="https://blog.bitomule.com/posts/getting-started-with-publish/">Getting started with publish</a> by my friend <a href="https://twitter.com/Bitomule">David Collado</a>.</li><li><a href="https://www.staskus.io/posts/2020-01-26-publish/">Migrating from Jekyll to Publish: A site generator for Swift developers</a> by <a href="https://twitter.com/PovilasStaskus">Povilas Staskus</a>.</li></ul><p>If you've reached this point chances are that you've completed Netflix and you do not have anything else to do, so here's a recommendation: go watch <a href="https://documentaryheaven.com/objectified/">Objectified</a> if you haven't yet. A great documentary on design and our relationships with products. Or you can always go to the <a href="https://vimeo.com/nsspain">NSSpain Vimeo channel</a> and watch a talk üòá.</p><p>Cheers ‚úåÔ∏è.</p>]]></content:encoded></item></channel></rss>